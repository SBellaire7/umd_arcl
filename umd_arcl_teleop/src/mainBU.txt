#include <ros/ros.h>
#include <string>
#include <sensor_msgs/Joy.h>
#include <std_msgs/Int32.h>
#include <std_msgs/Int32MultiArray.h>
#include <stdio.h>
#include <stdlib.h>

bool dmSw = 0;
int movSpd = 0;
int turnSpd = 0;
int mov = 0;
int turn = 0;

void joy2arcl(const sensor_msgs::Joy& msg)
{
  //Left joy controls fwd vel, and right joy controls turning
  float axMove = msg.axes[1];
  float axTurn = msg.axes[3];

  //deadman switch is either LB or RB
  dmSw = msg.buttons[4] | msg.buttons[5];

  //calculate velocities (1m/s or 100deg/s max)
  movSpd = axMove * 1000;
  turnSpd = axTurn * 100;
  mov = 750;
  if(movSpd < 0) mov = -300;
  turn = 90;
  if(turnSpd < 0) turn = -90;
}

int main(int argc, char** argv)
{
  //init ros
  ros::init(argc, argv, "arclTeleop");
  ros::NodeHandle nh;

  //subscribe to joystick node and publish to arcl driver
  ros::Subscriber joySub = nh.subscribe("/joy", 1, &joy2arcl);
  ros::Publisher arclMovePub = nh.advertise<std_msgs::Int32MultiArray>
    ("arcl/move", 1);
  ros::Publisher arclRotatePub = nh.advertise<std_msgs::Int32MultiArray>
    ("arcl/rotate", 1);

  //hand over control to ros master
  ros::Rate rate(2);
  while(ros::ok())
  {
    ros::spinOnce();
    std_msgs::Int32MultiArray msg;
    msg.data.clear();
    if(abs(turnSpd) > 0)
    {
      msg.data.push_back(turn);
      msg.data.push_back(abs(turnSpd));
      arclRotatePub.publish(msg);
    }
    else
    {
      msg.data.push_back(mov);
      msg.data.push_back(abs(movSpd));
      arclMovePub.publish(msg);
    }
    rate.sleep();
  }

  return 0;
}
